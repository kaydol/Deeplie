
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JPanel;

public class Canvas extends JPanel {

	private static final long serialVersionUID = -1354251777507926593L;
	private BufferedImage savedImage;
	private List<Node> trees, pool;
	
	public int drawLimit = 2;
	private double startAngle = 0;
	private double spray = Math.PI; // defines the cone of each branch
	private double r = 50; // the length of each edge
	private double nodesize = 10; 
	
	private double scale;
	private boolean draggingRMB = false, draggingLMB = false;
	private Point mouseLastPoint;
	private int shiftX, shiftY, shX, shY; // shX & shY - temporal shift (generated by mouse dragging), shiftX & shiftY - constant shift
	
	private Node selectedNode = null;
	
	public Canvas () {
		trees = new ArrayList<Node>();
		pool = new ArrayList<Node>();
		
		setFocusable(true);
		resetCanvas();
		addHandlers();
	}
	
	public void resetCanvas() {
		scale = 1;
		shX = shiftX = (int) 0;
		shY = shiftY = (int) 0;
	}
	
    private void createBackGround() {
        if (savedImage == null)
            return;
        Graphics2D g = (Graphics2D) savedImage.getGraphics();
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, savedImage.getWidth(), savedImage.getHeight());
        drawTrees(g);
        drawDirections(g);
        drawLegend(g);
    }
	
    public void paint(Graphics g) {
        if (g != null) {
            int W = getWidth();
            int H = getHeight();
            if ((W > 0) && (H > 0)) {    
            	savedImage = new BufferedImage(W, H, BufferedImage.TYPE_INT_RGB);
            	createBackGround();
            	g.drawImage(savedImage, 0, 0, null);
            }
        }
    }
    
    private void drawLegend(Graphics g) {
    	Font font = new Font("Verdana", Font.TRUETYPE_FONT, 12);
    	FontMetrics fontMetrics = getFontMetrics(font);
    	double widening = 1.2;
    	String[] hint = {
    			"Use [Right Mouse Button] and [Mouse Wheel] for navigating", 
    			"You can drag & drop red nodes to get rid of overlapping"
    			};
    	
    	g.setColor(Color.darkGray);
    	g.setFont(font);
    	
    	for (int i = 0; i < hint.length; ++i) {
    		int Y = (int) Math.round(getHeight() + 5 - widening * (hint.length - i) * fontMetrics.getHeight());
    		g.drawString(hint[i], 10, Y);
    	}
		
    }
    
    private void drawTrees(Graphics g) {
    	for (Node root: trees) {
    		for (Node node: pool)
    			node.resetDrawCounter();
    		
    		if (root.getPosition() == null) {
	    		root.setPosition(new Point2D.Double(100 + trees.indexOf(root) * 300, 50));
    		}
    		drawNode(g, root, angleMod(startAngle));
    	}
    }
    
    private void drawDirections(Graphics g) {
    	for (Node root: trees) {
    		Rectangle bounds = getBounds();
    		double x = (root.getPosition().getX() - shiftX) * scale + bounds.getX();
    		double y = (root.getPosition().getY() - shiftY) * scale + bounds.getY();
    		int size = (int) Math.round(nodesize * scale);
    		
    		if (bounds.contains(x, y)) {
    			// The dot is visible on the canvas
    		} else {
    			// Draw a 'shadow' on the edge of the canvas, casted by that node 
    			// Calculating the coordinates on the boundary
    			Line2D line = new Line2D.Double(bounds.getCenterX(), bounds.getCenterY(), x, y);
    			
    			// up, left, down, right
    			int px = (int) Math.round(6 / scale);
    			Line2D[] edges = new Line2D[] {
					new Line2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth() + px, bounds.getY()),
					new Line2D.Double(bounds.getX(), bounds.getY(), bounds.getX(), bounds.getHeight() + px),
					new Line2D.Double(bounds.getX(), bounds.getHeight() + px, bounds.getWidth() + px, bounds.getHeight() + px),
					new Line2D.Double(bounds.getWidth() + px, bounds.getY(), bounds.getWidth() + px, bounds.getHeight() + px)
    			};
    			
    			int xi = 0;
				int yi = 0;
    			for (Line2D edge : edges) {
    				if (!line.intersectsLine(edge)) 
    					continue;
    				
    				double x11 = line.getX1(), y11 = line.getY1(), x12 = line.getX2(), y12 = line.getY2();
    				double x21 = edge.getX1(), y21 = edge.getY1(), x22 = edge.getX2(), y22 = edge.getY2();

    				double a1 = y11 - y12; 
    				double b1 = x12 - x11;
    				double a2 = y21 - y22; 
    				double b2 = x22 - x21;

    				double d = a1 * b2 - a2 * b1;
    				if ( d != 0 ) { 
    					double c1 = y12 * x11 - x12 * y11;
    					double c2 = y22 * x21 - x22 * y21;
    					
	    				xi = (int) Math.round((b1 * c2 - b2 * c1) / d - bounds.getX());
    					yi = (int) Math.round((a2 * c1 - a1 * c2) / d - bounds.getY());
    				}
    				break;
    			}
    			g.setColor(Color.RED);
    			g.fillRect(xi, yi, size, size);
    		}
    	}
    }
    
    private void drawNode(Graphics g, Node node, double angle) {  	

    	int childrenCount = node.getChildren().size();
    	double step = spray / (double) (childrenCount  + 1);
    	//angle -= angle - spray / 2 + step;
    	
    	//if (childrenCount != 1) 
    		angle = angleMod(angle - spray / 2 + step);
    	Point2D position = node.getPosition();
    	
    	//////////////////////////////
    	//	Drawing current node	//
    	//////////////////////////////
    	
    	int x = (int) Math.round((position.getX() - nodesize / 2 - shiftX) * scale);
		int y = (int) Math.round((position.getY() - nodesize / 2 - shiftY) * scale);
		int size = (int) Math.round(nodesize * scale);
		
		boolean isRoot = node.getFathers().size() == 0;
		boolean isLeaf = node.getChildren().isEmpty();
		
		if (isRoot)
			g.setColor(Color.RED);
		else
			g.setColor(Color.BLACK);
		
		if (!node.checkDrawCounter(drawLimit)) {
			// this branch already was drawn, mark it as duplicate
			g.setColor(Color.GRAY);
			g.drawRect(x, y, size, size);
		} 
		else {
			if (isLeaf)
				g.fillRect(x, y, size, size);
			else
				g.drawRoundRect(x, y, size, size, size, size);
		}
		
		if (node.equals(selectedNode))
			g.drawRoundRect(x - size / 2, y - size / 2, size * 2, size * 2, size * 2, size * 2);

		g.setFont(new Font("Verdana", Font.TRUETYPE_FONT, 12));
		g.drawString(node.getLabel(), x + 5, y - 5);
		
    	//////////////////////////////
    	//	Drawing children		//
    	//////////////////////////////
    	
		if (!node.checkDrawCounter(drawLimit)) {
			// if the branch is a duplicate, we don't draw any children
			return;
		}
		
		
    	for (Node child: node.getChildren()) {

    			child.incDrawCounter();
    			Point2D pos = new Point2D.Double(position.getX() + r * Math.sin(angle), position.getY() + r * Math.cos(angle));
    			
    			int x1 = (int) Math.round((position.getX() - shiftX) * scale);
    			int y1 = (int) Math.round((position.getY() - shiftY) * scale);
    			int x2 = (int) Math.round((pos.getX() - shiftX) * scale);
    			int y2 = (int) Math.round((pos.getY() - shiftY) * scale);
    			
    			g.setColor(Color.BLACK);
    			g.drawLine(x1, y1, x2, y2);
    			
    			child.setPosition(pos);
    			drawNode(g, child, angle);
    			angle = angleMod(angle + step);
    	}
    }
    
	public void setData(List<Node> roots, List<Node> nodes) {
		trees = roots;
		pool = nodes;
	}
	
	
	//////////////////
	//	Handlers	//
	//////////////////

	public void addHandlers () {
		
		addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				
				MainWindow.requestFocusInCanvas();
				
				if (e.getButton() == MouseEvent.BUTTON1) {
					draggingLMB = true;
					mouseLastPoint = e.getPoint();
					
					double x = e.getX() / scale + shiftX;
					double y = e.getY() / scale + shiftY;
					
					selectedNode = findNodeByCoordinate(new Point2D.Double(x, y));
					if(selectedNode != null) {
						repaintCanvas();
						Main.window.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
					}
				}
				if (e.getButton() == MouseEvent.BUTTON3) {
					draggingRMB = true;
					mouseLastPoint = e.getPoint();
					Main.window.setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));	
				}
			}
			@Override
			public void mouseReleased(MouseEvent e) {
				if (e.getButton() == MouseEvent.BUTTON1) {
					draggingLMB = false;
					selectedNode = null;
					repaintCanvas();
					Main.window.setCursor(Cursor.getDefaultCursor());	
				}
				if (e.getButton() == MouseEvent.BUTTON3) {
					draggingRMB = false;
					shX += (mouseLastPoint.x - e.getPoint().x) * (1 / scale);
					shY += (mouseLastPoint.y - e.getPoint().y) * (1 / scale);
					Main.window.setCursor(Cursor.getDefaultCursor());				
				}
			}
		});

    	addMouseMotionListener(new MouseAdapter() {
			@Override
			public void mouseDragged(MouseEvent e) {
				if (draggingLMB) {

					if (selectedNode != null) {
						double x = e.getX() / scale + shiftX;
						double y = e.getY() / scale + shiftY;
						selectedNode.setPosition(new Point2D.Double(x, y));
					}
					repaintCanvas();
				}
				if (draggingRMB) {
					shiftX = (int) Math.round(shX + (mouseLastPoint.x - e.getPoint().x) * (1 / scale));
					shiftY = (int) Math.round(shY + (mouseLastPoint.y - e.getPoint().y) * (1 / scale));
					repaintCanvas();
				}
			}
		});
    	
    	addMouseWheelListener(new MouseAdapter() {
			@Override
			public void mouseWheelMoved(MouseWheelEvent e) {
				int rot = e.getWheelRotation();
				if (rot < 0) 
					scale += 0.2 * scale;
				else
					scale -= 0.2 * scale;
				shiftX = (int) Math.round(shX + (1 / scale));
				shiftY = (int) Math.round(shY + (1 / scale));
				repaintCanvas();
			}
		});
    	
    	
    	addKeyListener(new KeyAdapter() {
			public void keyPressed(KeyEvent k) {
				//System.out.println(KeyEvent.getKeyText(k.getKeyCode()));
				String keyText = KeyEvent.getKeyText(k.getKeyCode());
				
				if (keyText.equals("W") || keyText.equals("Up"))
					shiftY -= (int) Math.round(10 * (1 / scale));
				if (keyText.equals("A") || keyText.equals("Left"))
					shiftX -= (int) Math.round(10 * (1 / scale));
				if (keyText.equals("S") || keyText.equals("Down"))
					shiftY += (int) Math.round(10 * (1 / scale));
				if (keyText.equals("D") || keyText.equals("Right"))
					shiftX += (int) Math.round(10 * (1 / scale));
				
				repaintCanvas();
			}
    	});
    	
	}
	
	public void repaintCanvas() {
    	createBackGround();
    	Graphics g = this.getGraphics();
    	g.drawImage(savedImage, 0, 0, null);
	}
	
	private double angleMod(double angle) {
		while (angle < 0)
			angle += Math.PI * 2;
		angle %= Math.PI * 2;
		return angle;
	}
	
	public Node findNodeByCoordinate(Point2D e) {
		for (Node node: trees) {
			Point2D pos = node.getPosition();
			if (pos.distance(e) < nodesize)	{
				//System.out.println("Node selected: " + node.getLabel());
				return node;
			}
		}
		return null;
	}
}
